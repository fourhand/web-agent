from fastapi import FastAPI, WebSocket
from fastapi.middleware.cors import CORSMiddleware
from dotenv import load_dotenv
from openai import AzureOpenAI
from starlette.websockets import WebSocketDisconnect
import os, json, re, logging, base64
from datetime import datetime
import asyncio

load_dotenv()
logger = logging.getLogger("uvicorn.error")
logging.basicConfig(level=logging.INFO)

# Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû• ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
os.makedirs("debug_images", exist_ok=True)

# === Stateless ÏÑúÎ≤Ñ - Ïª®ÌÖçÏä§Ìä∏Îäî ExtensionÏóêÏÑú Í¥ÄÎ¶¨ ===
# ConversationContext ÌÅ¥ÎûòÏä§ÏôÄ ÏÑ∏ÏÖò Í¥ÄÎ¶¨ Ï†úÍ±∞Îê®
# Î™®Îì† Ïª®ÌÖçÏä§Ìä∏Îäî ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÏÑú Ï†ÑÏÜ°Îê®

app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"]
)

async def refine_prompt_with_llm(user_message: str) -> str:
    client = AzureOpenAI(
        api_key=os.getenv("AZURE_OPENAI_API_KEY"),
        api_version="2024-02-15-preview",
        azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT")
    )
    refine_prompt = f'''
ÏïÑÎûò ÏÇ¨Ïö©ÏûêÏùò ÏûÖÎ†•ÏùÑ Î∏åÎùºÏö∞Ï†Ä ÏûêÎèôÌôî Î™ÖÎ†πÎ¨∏(Ìïú Î¨∏Ïû•, Î™ÖÌôïÌïòÍ≥† Í∞ÑÍ≤∞ÌïòÍ≤å)ÏúºÎ°ú Î≥ÄÌôòÌï¥ Ï£ºÏÑ∏Ïöî.
Î™ÖÎ†πÎ¨∏ÏùÄ Î∞òÎìúÏãú ÏßÅÏ†ëÏ†ÅÏù¥Í≥† Íµ¨Ï≤¥Ï†ÅÏúºÎ°ú ÏûëÏÑ±ÌïòÏÑ∏Ïöî.

ÏûÖÎ†•: "{user_message}"

Ï∂úÎ†• ÏòàÏãú:
- "Î©îÏùºÌï®ÏúºÎ°ú Í∞ÄÏÑú Ï≤´ Î≤àÏß∏ Î©îÏùºÏùÑ ÏùΩÏñ¥Ï§ò" ‚Üí "Î©îÏùºÌï®ÏúºÎ°ú Ïù¥Îèô ÌõÑ Ï≤´ Î≤àÏß∏ Î©îÏùº ÌÅ¥Î¶≠"
- "Î°úÍ∑∏Ïù∏ Î≤ÑÌäºÏù¥ ÏûàÏúºÎ©¥ ÎàåÎü¨Ï§ò" ‚Üí "Î°úÍ∑∏Ïù∏ Î≤ÑÌäº ÌÅ¥Î¶≠"
- "Í≤ÄÏÉâÏ∞ΩÏóê 'AI' ÏûÖÎ†•ÌïòÍ≥† Í≤ÄÏÉâ Î≤ÑÌäº ÌÅ¥Î¶≠" ‚Üí "Í≤ÄÏÉâÏ∞ΩÏóê 'AI' ÏûÖÎ†• ÌõÑ Í≤ÄÏÉâ Î≤ÑÌäº ÌÅ¥Î¶≠"

Î™ÖÎ†πÎ¨∏:
'''
    response = client.chat.completions.create(
        model=os.getenv("AZURE_OPENAI_DEPLOYMENT_NAME", "gpt-4.1-mini"),
        messages=[{"role": "user", "content": refine_prompt}],
        max_tokens=100,
        temperature=0.1
    )
    return response.choices[0].message.content.strip().replace('\n', ' ')

def compress_dom(dom: list) -> list:
    compressed = []
    for el in dom:
        if not el.get("selector"):
            continue
        
        # Îçî Ï†ïÌôïÌïú ÏÑ†ÌÉùÏûê ÏÉùÏÑ±
        selector = el.get("selector")
        tag = el.get("tag")
        
        # Ïö∞ÏÑ†ÏàúÏúÑ: id > name > class > tag
        if el.get("id"):
            selector = f"#{el['id']}"
        elif el.get("name"):
            selector = f"{tag}[name='{el['name']}']"
        elif el.get("type"):
            selector = f"{tag}[type='{el['type']}']"
        elif selector and not selector.startswith("#") and not selector.startswith("."):
            # Í∏∞Ï°¥ ÏÑ†ÌÉùÏûêÍ∞Ä Îã®ÏàúÌïú Í≤ΩÏö∞ Ïú†ÏßÄ
            pass
        else:
            # Í∏∞Î≥∏ ÌÉúÍ∑∏ ÏÑ†ÌÉùÏûê
            selector = tag
        
        entry = {
            "tag": tag,
            "selector": selector
        }
        
        # Ï∂îÍ∞Ä ÏÜçÏÑ±Îì§
        if el.get("type"):
            entry["type"] = el["type"]
        if el.get("id"):
            entry["id"] = el["id"]
        if el.get("name"):
            entry["name"] = el["name"]
        if el.get("class"):
            entry["class"] = el["class"]
            
        if txt := el.get("text"):
            txt = txt.strip()
            if txt:
                entry["text"] = txt[:50]  # ÌÖçÏä§Ìä∏ Í∏∏Ïù¥ Ï¶ùÍ∞Ä
                
        compressed.append(entry)
    return compressed[:50]  # Îçî ÎßéÏùÄ ÏöîÏÜå Ìè¨Ìï®

def build_planning_prompt_with_image(goal: str, dom_summary: list, context: dict = None) -> str:
    context_info = ""
    if context:
        context_info = f"""
CONTEXT INFORMATION:
- Current Step: {context.get('step', 0)}
- Previous Actions: {len(context.get('conversationHistory', []))} messages
- Last Action: {json.dumps(context.get('lastAction'), ensure_ascii=False) if context.get('lastAction') else 'None'}
"""

    return f"""
You are a browser automation planner with visual understanding. Analyze the goal and current DOM to create a detailed step-by-step plan.

üé® VISUAL WIREFRAME GUIDE:
The attached image is a structured wireframe representation of the webpage with color-coded elements:
- üîµ BLUE background + thick border = BUTTONS (clickable actions)
- ‚ö™ LIGHT GRAY background = INPUT FIELDS/TEXTAREAS (fillable)
- üü° YELLOW background = SELECT DROPDOWNS (selectable options)
- üîó BLUE dotted border = LINKS (navigation)
- üü† ORANGE background + thick border = HEADINGS (H1-H6, important text)
- üü¢ GREEN background + [IMG] = IMAGES (visual content)
- üü£ PURPLE dotted border = LISTS (UL/OL/LI items)
- üî∑ LIGHT BLUE background + dotted border = FORMS (form containers)
- Gray thin border = Other elements (DIV, SPAN, etc.)

This wireframe shows the exact layout, element positions, and text content clearly for precise automation.

Goal: "{goal}"
{context_info}
Current DOM Summary:
{json.dumps(dom_summary, ensure_ascii=False, indent=2)}

Create a detailed plan with 3-8 steps. Each step should be specific and actionable.
Use both the visual wireframe and DOM summary to understand the page structure.

‚ö†Ô∏è BROWSER SECURITY LIMITATIONS:
- CANNOT control browser UI elements (address bar, back/forward buttons, tabs)
- CANNOT use "focus", "fill", or "press" actions on browser UI
- CAN ONLY control DOM elements within the current webpage
- For navigation, use "goto" action with full URL instead of typing in address bar

IMPORTANT SELECTOR GUIDELINES:
1. Use EXACT selectors from the DOM summary above when available
2. Prefer simple, reliable selectors: id > name > type > class > tag
3. Avoid complex CSS selectors like "ul.mail_list > li:first-child"
4. If exact selector not available, use text-based matching
5. For lists, prefer "li" with text content rather than complex selectors
6. For buttons/links, prefer "a" or "button" with text content
7. Use the visual wireframe to understand element relationships and positioning

Return ONLY a JSON array like:
[
  {{"step": 1, "action": "goto", "target": "navigate to website", "reason": "Navigate to target site", "url": "https://example.com"}},
  {{"step": 2, "action": "click", "target": "login button", "reason": "Start login process", "selector": "button[type='submit']"}},
  {{"step": 3, "action": "fill", "target": "username field", "reason": "Enter credentials", "selector": "input[name='username']", "value": "username"}}
]

Guidelines:
- Each step should be atomic and specific
- Use selectors from the DOM summary when possible
- Prefer id, name, or specific attributes over complex CSS selectors
- If exact selector not available, use text-based matching
- Plan should be logical and efficient
- Leverage the visual wireframe to understand layout and element relationships
- Consider element colors in the wireframe to identify element types quickly
"""

def build_execution_prompt_with_image(goal: str, plan: list, current_step: int, dom_summary: list, context: dict = None) -> str:
    context_info = ""
    if context:
        context_info = f"""
CONTEXT INFORMATION:
- Session ID: {context.get('sessionId', 'unknown')}
- Current Step: {context.get('step', current_step)}
- Total Actions: {context.get('totalActions', 0)}
- Last Action: {json.dumps(context.get('lastAction'), ensure_ascii=False) if context.get('lastAction') else 'None'}
"""

    rules = f"""
‚ö†Ô∏è Guidelines:
- If a dropdown or submenu is involved: hover the parent, waitUntil it appears, then click.
- Do NOT repeat the same action if DOM did not change.
- Each step must return only one atomic action.
- Return {{"action": "end"}} if the goal is completed.
- Use the visual wireframe to understand layout and identify elements precisely.

üé® VISUAL WIREFRAME LEGEND:
- üîµ BLUE background = BUTTONS (clickable)
- ‚ö™ LIGHT GRAY background = INPUT FIELDS (fillable)
- üü° YELLOW background = SELECT DROPDOWNS
- üîó BLUE dotted border = LINKS
- üü† ORANGE background = HEADINGS (H1-H6)
- üü¢ GREEN background + [IMG] = IMAGES
- üü£ PURPLE dotted border = LISTS
- üî∑ LIGHT BLUE background = FORMS
- Gray thin border = Other elements

üö´ BROWSER SECURITY LIMITATIONS:
- CANNOT control browser UI elements (address bar, back/forward buttons, tabs)
- CANNOT use "focus", "fill", or "press" actions on browser UI
- CAN ONLY control DOM elements within the current webpage
- For navigation, use "goto" action with full URL instead of typing in address bar
"""

    return f"""
You are executing step {current_step} of a browser automation plan with visual understanding.

The attached image is a color-coded wireframe showing the exact page structure. Use both the visual wireframe and DOM data to identify elements accurately.

Goal: "{goal}"
Current Step: {current_step}
Plan: {json.dumps(plan, ensure_ascii=False, indent=2)}
{context_info}

DOM Summary:
{json.dumps(dom_summary, ensure_ascii=False, indent=2)}

{rules}

Execute ONLY the current step. Return JSON:
{{
  "action": "click" | "fill" | "goto" | "hover" | "waitUntil" | "end",
  "selector": "<CSS selector>",
  "text": "optional text for matching",
  "value": "optional value",
  "url": "full URL for goto action",
  "condition": "optional condition selector",
  "timeout": 1000
}}
"""

def build_prompt_with_image(goal: str, dom_summary: list, step: int, context: dict = None) -> str:
    context_info = ""
    if context:
        context_info = f"""
CONTEXT INFORMATION:
- Session ID: {context.get('sessionId', 'unknown')}
- Current Step: {context.get('step', step)}
- Total Actions: {context.get('totalActions', 0)}
- Last Action: {json.dumps(context.get('lastAction'), ensure_ascii=False) if context.get('lastAction') else 'None'}
"""

    rules = """
‚ö†Ô∏è Guidelines:
- If a dropdown or submenu is involved: hover the parent, waitUntil it appears, then click.
- Do NOT repeat the same action if DOM did not change.
- Each step must return only one atomic action.
- Return {"action": "end"} if the goal is completed.
- Use the visual wireframe to understand layout and identify elements precisely.

üé® VISUAL WIREFRAME LEGEND:
The attached image uses color-coding to identify different element types:
- üîµ BLUE background = BUTTONS (clickable actions)
- ‚ö™ LIGHT GRAY background = INPUT FIELDS/TEXTAREAS (fillable)
- üü° YELLOW background = SELECT DROPDOWNS (selectable)
- üîó BLUE dotted border = LINKS (navigation)
- üü† ORANGE background = HEADINGS (H1-H6, important text)
- üü¢ GREEN background + [IMG] = IMAGES (visual content)
- üü£ PURPLE dotted border = LISTS (UL/OL/LI items)
- üî∑ LIGHT BLUE background = FORMS (form containers)
- Gray thin border = Other elements (DIV, SPAN, etc.)
"""

    return f"""
You are a browser control agent (MCP) with visual understanding.

The attached image is a structured wireframe showing the webpage layout with color-coded elements for easy identification.

Goal: "{goal}"
Step: {step}
{context_info}

DOM Summary:
{json.dumps(dom_summary, ensure_ascii=False, indent=2)}

{rules}

Respond ONLY with one JSON object like:
{{
  "action": "click" | "fill" | "goto" | "hover" | "waitUntil" | "end",
  "selector": "<CSS selector>",
  "text": "optional text for matching",
  "value": "optional value",
  "url": "full URL for goto action",
  "condition": "optional condition selector",
  "timeout": 1000
}}
"""

def clean_action(action: dict) -> dict:
    if action.get("action") in ["click", "hover"]:
        action.pop("value", None)
    if action.get("action") != "extract":
        action.pop("extract", None)
        action.pop("attribute", None)
    return action

def save_debug_image(image_data: str, step: int, goal: str = None) -> str:
    """Î∞õÏùÄ Ïù¥ÎØ∏ÏßÄÎ•º PNGÎ°ú Ï†ÄÏû•ÌïòÍ≥† ÌååÏùº Í≤ΩÎ°ú Î∞òÌôò"""
    try:
        logger.info(f"üíæ Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû• ÏãúÏûë (Ïä§ÌÖù: {step}, Î™©Ìëú: {goal})")
        
        # base64 Îç∞Ïù¥ÌÑ∞ URLÏóêÏÑú Ïã§Ï†ú base64 Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
        original_data = image_data
        if image_data.startswith('data:image'):
            # "data:image/png;base64," Î∂ÄÎ∂Ñ Ï†úÍ±∞
            image_data = image_data.split(',')[1]
            logger.info("‚úÖ base64 Îç∞Ïù¥ÌÑ∞ URL ÌòïÏãù ÌôïÏù∏Îê®")
        else:
            logger.warning("‚ö†Ô∏è base64 Îç∞Ïù¥ÌÑ∞ URL ÌòïÏãùÏù¥ ÏïÑÎãò, ÏõêÎ≥∏ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©")
        
        # base64 ÎîîÏΩîÎî©
        image_bytes = base64.b64decode(image_data)
        logger.info(f"‚úÖ base64 ÎîîÏΩîÎî© ÏôÑÎ£å: {len(image_bytes)} bytes")
        
        # ÌååÏùºÎ™Ö ÏÉùÏÑ± (Î™©Ìëú + Ïä§ÌÖù + ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Î™©ÌëúÎ•º ÌååÏùºÎ™ÖÏóê Ìè¨Ìï® (Í∞ÑÎã®ÌïòÍ≤å)
        goal_safe = ""
        if goal:
            # Î™©ÌëúÏóêÏÑú ÏïàÏ†ÑÌïú Î¨∏ÏûêÎßå Ï∂îÏ∂ú
            goal_words = goal.split()[:3]  # Ï≤òÏùå 3Í∞ú Îã®Ïñ¥Îßå
            goal_safe = "_" + "_".join(goal_words).replace(" ", "_")[:20]
            goal_safe = goal_safe.replace("/", "_").replace("\\", "_")  # ÏïàÏ†ÑÌïòÏßÄ ÏïäÏùÄ Î¨∏Ïûê Ï†úÍ±∞
        
        filename = f"debug_images/step_{step}{goal_safe}_{timestamp}.png"
        logger.info(f"üìù ÌååÏùºÎ™Ö: {filename}")
        
        # PNGÎ°ú Ï†ÄÏû• (ÏõêÎ≥∏ ÌòïÏãù Ïú†ÏßÄ)
        with open(filename, 'wb') as f:
            f.write(image_bytes)
        
        # ÌååÏùº ÌÅ¨Í∏∞ ÌôïÏù∏
        file_size = len(image_bytes)
        file_size_kb = file_size / 1024
        
        logger.info(f"üíæ Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû• ÏôÑÎ£å: {filename}")
        logger.info(f"   üìä ÌååÏùº ÌÅ¨Í∏∞: {file_size_kb:.1f} KB ({file_size} bytes)")
        logger.info(f"   üìê Ïù¥ÎØ∏ÏßÄ Ï†ïÎ≥¥: PNG ÌòïÏãù, base64 ÎîîÏΩîÎî© ÏôÑÎ£å")
        
        return filename
    except Exception as e:
        logger.error(f"‚ùå Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû• Ïã§Ìå®: {e}")
        logger.error(f"   üîç ÏõêÎ≥∏ Îç∞Ïù¥ÌÑ∞ Í∏∏Ïù¥: {len(original_data) if original_data else 0}")
        logger.error(f"   üîç Ï≤òÎ¶¨Îêú Îç∞Ïù¥ÌÑ∞ Í∏∏Ïù¥: {len(image_data) if image_data else 0}")
        logger.error(f"   üîç Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖ: {type(image_data)}")
        logger.error(f"   üîç Îç∞Ïù¥ÌÑ∞ Ï†ëÎëêÏÇ¨: {image_data[:50] if image_data else 'None'}...")
        return None

async def call_llm_with_image(prompt: str, image_data: str):
    """Ïù¥ÎØ∏ÏßÄÏôÄ Ìï®Íªò LLM Ìò∏Ï∂ú"""
    try:
        client = AzureOpenAI(
            api_key=os.getenv("AZURE_OPENAI_API_KEY"),
            api_version="2024-02-15-preview",
            azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT")
        )
        
        # base64 Îç∞Ïù¥ÌÑ∞ URLÏóêÏÑú Ïã§Ï†ú base64 Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
        if image_data.startswith('data:image'):
            image_data = image_data.split(',')[1]
        
        response = client.chat.completions.create(
            model=os.getenv("AZURE_OPENAI_VISION_DEPLOYMENT_NAME", "gpt-4.1-mini"),
            messages=[
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": prompt},
                        {"type": "image_url", "image_url": {"url": f"data:image/png;base64,{image_data}"}}
                    ]
                }
            ],
            max_tokens=500,
            temperature=0.1
        )
        
        return response.choices[0].message.content
    except Exception as e:
        logger.error(f"Vision API Ìò∏Ï∂ú Ïã§Ìå®: {e}")
        return None

async def call_llm(prompt: str):
    """ÌÖçÏä§Ìä∏ Ï†ÑÏö© LLM Ìò∏Ï∂ú (stateless)"""
    try:
        client = AzureOpenAI(
            api_key=os.getenv("AZURE_OPENAI_API_KEY"),
            api_version="2024-02-15-preview",
            azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT")
        )
        
        messages = [{"role": "user", "content": prompt}]
        
        response = client.chat.completions.create(
            model=os.getenv("AZURE_OPENAI_DEPLOYMENT_NAME", "gpt-4.1-mini"),
            messages=messages,
            max_tokens=500,
            temperature=0.1
        )
        
        return response.choices[0].message.content
    except Exception as e:
        logger.error(f"LLM Ìò∏Ï∂ú Ïã§Ìå®: {e}")
        return None

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    logger.info("üîå WebSocket Ïó∞Í≤∞ ÏàòÎùΩÎê® (Stateless ÏÑúÎ≤Ñ)")

    try:
        while True:
            logger.info("‚è≥ Î©îÏãúÏßÄ ÎåÄÍ∏∞ Ï§ë...")
            raw = await websocket.receive_text()
            logger.info(f"üì® Î©îÏãúÏßÄ ÏàòÏã†: {len(raw)} characters")
            
            try:
                payload = json.loads(raw)
                logger.info(f"üìã Î©îÏãúÏßÄ ÌÉÄÏûÖ: {payload.get('type')}")
                logger.info(f"üìã Î©îÏãúÏßÄ ÌÇ§Îì§: {list(payload.keys())}")
            except json.JSONDecodeError as e:
                logger.error(f"‚ùå JSON ÌååÏã± Ïã§Ìå®: {e}")
                logger.error(f"‚ùå ÏõêÎ≥∏ Îç∞Ïù¥ÌÑ∞: {raw[:200]}...")
                continue

            if payload.get("type") == "init":
                # Îã®ÏàúÌïú Ï¥àÍ∏∞Ìôî ÌôïÏù∏
                user_goal = payload["message"]
                logger.info(f"üÜï ÏÉà Î™©Ìëú: {user_goal}")
                
                await websocket.send_text(json.dumps({
                    "type": "init_confirmed",
                    "message": "Î™©ÌëúÍ∞Ä ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§. DOMÏùÑ Ï†ÑÏÜ°Ìï¥Ï£ºÏÑ∏Ïöî."
                }))
                continue

            if payload.get("type") == "dom_with_image":
                logger.info("üîÑ DOM + Ïù¥ÎØ∏ÏßÄ Ï≤òÎ¶¨ ÏãúÏûë")
                
                # Ïª®ÌÖçÏä§Ìä∏ Ï†ïÎ≥¥ Ï∂îÏ∂ú
                context = payload.get("context", {})
                goal = context.get("goal", payload.get("message", ""))
                step = context.get("step", 0)
                plan = context.get("plan", [])
                
                logger.info(f"üìã Ïª®ÌÖçÏä§Ìä∏ Ï†ïÎ≥¥:")
                logger.info(f"   - Î™©Ìëú: {goal}")
                logger.info(f"   - Îã®Í≥Ñ: {step}")
                logger.info(f"   - Í≥ÑÌöç: {len(plan)}Í∞ú Îã®Í≥Ñ")
                logger.info(f"   - Ï¥ù Ïï°ÏÖò: {context.get('totalActions', 0)}Í∞ú")
                
                if not goal:
                    logger.warning("‚ö†Ô∏è Î™©ÌëúÍ∞Ä ÏóÜÏäµÎãàÎã§.")
                    await websocket.send_text(json.dumps({
                        "type": "error",
                        "detail": "Î™©ÌëúÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§."
                    }))
                    continue
                
                # DOM Ï≤òÎ¶¨
                try:
                    dom_summary = compress_dom(payload["dom"])
                    logger.info(f"üìä DOM ÏïïÏ∂ï ÏôÑÎ£å: {len(dom_summary)} ÏöîÏÜå")
                except Exception as e:
                    logger.error(f"‚ùå DOM ÏïïÏ∂ï Ïã§Ìå®: {e}")
                    continue
                
                image_data = payload.get("image")
                
                # Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû•
                if image_data:
                    saved_path = save_debug_image(image_data, step, goal)
                    if saved_path:
                        logger.info(f"‚úÖ Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû• ÏôÑÎ£å: {saved_path}")
                
                # Planning Îã®Í≥Ñ (Í≥ÑÌöçÏù¥ ÏóÜÎäî Í≤ΩÏö∞)
                if not plan and step == 0:
                    logger.info("üß† Planning Îã®Í≥Ñ ÏãúÏûë...")
                    
                    if image_data:
                        plan_response = await call_llm_with_image(
                            build_planning_prompt_with_image(goal, dom_summary, context), 
                            image_data
                        )
                    else:
                        plan_response = await call_llm(
                            build_planning_prompt_with_image(goal, dom_summary, context)
                        )
                    
                    if plan_response:
                        plan_match = re.search(r'\[.*\]', plan_response, re.DOTALL)
                        if plan_match:
                            try:
                                parsed_plan = json.loads(plan_match.group())
                                logger.info(f"‚úÖ Planning ÏôÑÎ£å: {len(parsed_plan)} Ïä§ÌÖù Í≥ÑÌöç")
                                
                                await websocket.send_text(json.dumps({
                                    "type": "plan",
                                    "plan": parsed_plan
                                }))
                                continue  # PlanningÎßå ÌïòÍ≥† ÎÅù
                            except json.JSONDecodeError as e:
                                logger.error(f"‚ùå Planning JSON ÌååÏã± Ïã§Ìå®: {e}")
                
                # Execution Îã®Í≥Ñ
                logger.info(f"üöÄ Execution Îã®Í≥Ñ: Step {step}")
                
                if image_data:
                    if plan:
                        prompt = build_execution_prompt_with_image(goal, plan, step, dom_summary, context)
                    else:
                        prompt = build_prompt_with_image(goal, dom_summary, step, context)
                    response = await call_llm_with_image(prompt, image_data)
                else:
                    # ÌÖçÏä§Ìä∏ Ï†ÑÏö©ÏùÄ Í∞ÑÎã®ÌïòÍ≤å Ï≤òÎ¶¨
                    prompt = f"Goal: {goal}\nStep: {step}\nDOM: {json.dumps(dom_summary, ensure_ascii=False, indent=2)}\nReturn next action as JSON."
                    response = await call_llm(prompt)

                if not response:
                    logger.error("‚ùå LLM ÏùëÎãµ ÏóÜÏùå")
                    await websocket.send_text(json.dumps({
                        "type": "error",
                        "detail": "LLM Ìò∏Ï∂ú Ïã§Ìå®"
                    }))
                    continue

                logger.info(f"üß† LLM ÏùëÎãµ: {response[:200]}...")

                # JSON Ï∂îÏ∂ú
                json_match = re.search(r'\{.*\}', response, re.DOTALL)
                if not json_match:
                    logger.error(f"‚ùå JSON ÌååÏã± Ïã§Ìå®: {response}")
                    await websocket.send_text(json.dumps({
                        "type": "error",
                        "detail": f"JSON ÌååÏã± Ïã§Ìå®: {response}"
                    }))
                    continue

                try:
                    action = json.loads(json_match.group())
                    action = clean_action(action)
                    logger.info(f"‚úÖ Ïï°ÏÖò ÌååÏã± ÏÑ±Í≥µ: {action}")
                    
                    if action.get("action") == "end":
                        logger.info("üéØ ÏûëÏóÖ ÏôÑÎ£å")
                        await websocket.send_text(json.dumps({"type": "end"}))
                    else:
                        logger.info(f"üöÄ Ïï°ÏÖò Ï†ÑÏÜ°: {action}")
                        await websocket.send_text(json.dumps({
                            "type": "action",
                            "step": step,
                            "action": action
                        }))
                except json.JSONDecodeError as e:
                    logger.error(f"‚ùå JSON ÎîîÏΩîÎî© Ïò§Î•ò: {e}")
                    await websocket.send_text(json.dumps({
                        "type": "error",
                        "detail": f"JSON ÌååÏã± Ïò§Î•ò: {e}"
                    }))

    except WebSocketDisconnect:
        logger.info("üîå WebSocket Ïó∞Í≤∞ Ìï¥Ï†úÎê®")
    except Exception as e:
        logger.error(f"‚ùå WebSocket Ïò§Î•ò: {e}")
        try:
            await websocket.send_text(json.dumps({
                "type": "error",
                "detail": str(e)
            }))
        except:
            pass

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)